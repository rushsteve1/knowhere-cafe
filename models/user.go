package models

import (
	"crypto/sha1"
	"database/sql"
	"encoding/binary"
	"fmt"
	"time"

	"github.com/go-webauthn/webauthn/webauthn"
	"github.com/google/uuid"
	"github.com/lib/pq"
	"gorm.io/gorm"
	"knowhere.cafe/src/shared"
)

type User struct {
	gorm.Model
	Email       string         `gorm:"uniqueIndex;not null"`
	LastSeenAt  time.Time      `gorm:"not null"`
	Roles       pq.StringArray `gorm:"type:text[];not null;default:'{}'"`
	EmailHidden bool           `gorm:"default:true;not null"`
	Bio         string         `gorm:"default:'';not null"`

	InvitedByID *uint
	InvitedBy   *User  `gorm:"foreignKey:InvitedByID"`
	Invitees    []User `gorm:"foreignKey:InvitedByID"`

	// TODO store what invite link used?

	Invites []Invite
	Posts   []Post `gorm:"foreignKey:AuthorID"`
	Reports []Report
	Logins  []Login

	Groups []Group `gorm:"many2many:user_groups"`

	permissions shared.Cached[Permissions]
}

func defaultRootUser(cfg *Config) User {
	return User{
		Email:      fmt.Sprintf("%s@%s", cfg.RootName, cfg.DomainName),
		LastSeenAt: time.Now(),
	}
}

// All of the possible Roles a user has.
// These are in order of priority, with the last having the highest priority
func (u User) AllRoles() []string {
	roles := make([]string, 0, len(u.Roles)+len(u.Groups)+3)

	// Default roles have the lowest priority
	roles = append(roles, shared.ANON_USER_ROLE, shared.REGISTERED_USER_ROLE)

	// Then groups
	for _, g := range u.Groups {
		roles = append(roles, g.Name)
	}

	// Then specific roles
	roles = append(roles, u.Roles...)

	// Finally the user's specific email has the highest priority
	return append(roles, u.Email)
}

// Calculate the final permissions for a user based on all their roles
func (u *User) Permissions(db *gorm.DB) (out Permissions, err error) {
	// Try to use the cache
	out, err = u.permissions.Get()
	if err == nil {
		return out, nil
	}

	var perms []Permissions
	res := db.Find(&perms, "applies_to in ?", u.AllRoles())
	if res.Error != nil {
		return out, res.Error
	}

	out = FlattenPermissions(u.AllRoles(), perms)
	u.permissions = shared.Cache(out, time.Hour)

	return out, nil
}

// Invite generated by a user
type Invite struct {
	gorm.Model
	Uuid      uuid.UUID `gorm:"uniqueIndex"`
	UserID    uint      `gorm:"not null"`
	Limit     sql.NullInt16
	ExpiresAt sql.NullTime
}

// Login generated by the user, ie a "Magic Link"
type Login struct {
	gorm.Model
	Uuid      uuid.UUID `gorm:"uniqueIndex"`
	UserID    uint      `gorm:"not null"`
	ExpiresAt time.Time `gorm:"not null"`
}

// WebAuthn
// https://pkg.go.dev/github.com/go-webauthn/webauthn/webauthn#User

func (u User) WebAuthnID() []byte {
	// TODO ensure this is valid and secure
	hasher := sha1.New()
	binary.Write(hasher, binary.NativeEndian, u.ID)
	return hasher.Sum(nil)
}

func (u User) WebAuthnName() string {
	return u.Email
}

func (u User) WebAuthnDisplayName() string {
	return u.WebAuthnName()
}

func (u User) WebAuthnCredentials() []webauthn.Credential {
	return nil
}
